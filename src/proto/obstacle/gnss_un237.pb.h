// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gnss_un237.proto

#ifndef PROTOBUF_gnss_5fun237_2eproto__INCLUDED
#define PROTOBUF_gnss_5fun237_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "header.pb.h"
#include "geometry.pb.h"
// @@protoc_insertion_point(includes)
namespace usv {
namespace localization {
namespace gnss {
class InsStat;
class InsStatDefaultTypeInternal;
extern InsStatDefaultTypeInternal _InsStat_default_instance_;
class InsTime;
class InsTimeDefaultTypeInternal;
extern InsTimeDefaultTypeInternal _InsTime_default_instance_;
class Ins_un237;
class Ins_un237DefaultTypeInternal;
extern Ins_un237DefaultTypeInternal _Ins_un237_default_instance_;
}  // namespace gnss
}  // namespace localization
}  // namespace usv

namespace usv {
namespace localization {
namespace gnss {

namespace protobuf_gnss_5fun237_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_gnss_5fun237_2eproto

enum InsStat_LocationStat {
  InsStat_LocationStat_LOCATION_VALID = 0,
  InsStat_LocationStat_LOCATION_INVALID = 1
};
bool InsStat_LocationStat_IsValid(int value);
const InsStat_LocationStat InsStat_LocationStat_LocationStat_MIN = InsStat_LocationStat_LOCATION_VALID;
const InsStat_LocationStat InsStat_LocationStat_LocationStat_MAX = InsStat_LocationStat_LOCATION_INVALID;
const int InsStat_LocationStat_LocationStat_ARRAYSIZE = InsStat_LocationStat_LocationStat_MAX + 1;

const ::google::protobuf::EnumDescriptor* InsStat_LocationStat_descriptor();
inline const ::std::string& InsStat_LocationStat_Name(InsStat_LocationStat value) {
  return ::google::protobuf::internal::NameOfEnum(
    InsStat_LocationStat_descriptor(), value);
}
inline bool InsStat_LocationStat_Parse(
    const ::std::string& name, InsStat_LocationStat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InsStat_LocationStat>(
    InsStat_LocationStat_descriptor(), name, value);
}
enum InsStat_DirectionFinderStat {
  InsStat_DirectionFinderStat_GPS_ORIENTATION = 0,
  InsStat_DirectionFinderStat_GYRO_ORIENTATION = 1
};
bool InsStat_DirectionFinderStat_IsValid(int value);
const InsStat_DirectionFinderStat InsStat_DirectionFinderStat_DirectionFinderStat_MIN = InsStat_DirectionFinderStat_GPS_ORIENTATION;
const InsStat_DirectionFinderStat InsStat_DirectionFinderStat_DirectionFinderStat_MAX = InsStat_DirectionFinderStat_GYRO_ORIENTATION;
const int InsStat_DirectionFinderStat_DirectionFinderStat_ARRAYSIZE = InsStat_DirectionFinderStat_DirectionFinderStat_MAX + 1;

const ::google::protobuf::EnumDescriptor* InsStat_DirectionFinderStat_descriptor();
inline const ::std::string& InsStat_DirectionFinderStat_Name(InsStat_DirectionFinderStat value) {
  return ::google::protobuf::internal::NameOfEnum(
    InsStat_DirectionFinderStat_descriptor(), value);
}
inline bool InsStat_DirectionFinderStat_Parse(
    const ::std::string& name, InsStat_DirectionFinderStat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InsStat_DirectionFinderStat>(
    InsStat_DirectionFinderStat_descriptor(), name, value);
}
enum InsStat_GPSLocationStat {
  InsStat_GPSLocationStat_GPS_NO_LOCATION = 0,
  InsStat_GPSLocationStat_GPS_SINGLE_LOCATION = 1,
  InsStat_GPSLocationStat_GPS_DIFF_LOCATION = 2,
  InsStat_GPSLocationStat_GPS_RTK_FIXED_LOCATION = 3,
  InsStat_GPSLocationStat_GPS_RTK_FLOAT_LOCATION = 4
};
bool InsStat_GPSLocationStat_IsValid(int value);
const InsStat_GPSLocationStat InsStat_GPSLocationStat_GPSLocationStat_MIN = InsStat_GPSLocationStat_GPS_NO_LOCATION;
const InsStat_GPSLocationStat InsStat_GPSLocationStat_GPSLocationStat_MAX = InsStat_GPSLocationStat_GPS_RTK_FLOAT_LOCATION;
const int InsStat_GPSLocationStat_GPSLocationStat_ARRAYSIZE = InsStat_GPSLocationStat_GPSLocationStat_MAX + 1;

const ::google::protobuf::EnumDescriptor* InsStat_GPSLocationStat_descriptor();
inline const ::std::string& InsStat_GPSLocationStat_Name(InsStat_GPSLocationStat value) {
  return ::google::protobuf::internal::NameOfEnum(
    InsStat_GPSLocationStat_descriptor(), value);
}
inline bool InsStat_GPSLocationStat_Parse(
    const ::std::string& name, InsStat_GPSLocationStat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InsStat_GPSLocationStat>(
    InsStat_GPSLocationStat_descriptor(), name, value);
}
// ===================================================================

class InsStat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:usv.localization.gnss.InsStat) */ {
 public:
  InsStat();
  virtual ~InsStat();

  InsStat(const InsStat& from);

  inline InsStat& operator=(const InsStat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsStat(InsStat&& from) noexcept
    : InsStat() {
    *this = ::std::move(from);
  }

  inline InsStat& operator=(InsStat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsStat& default_instance();

  static inline const InsStat* internal_default_instance() {
    return reinterpret_cast<const InsStat*>(
               &_InsStat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(InsStat* other);
  friend void swap(InsStat& a, InsStat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsStat* New() const PROTOBUF_FINAL { return New(NULL); }

  InsStat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InsStat& from);
  void MergeFrom(const InsStat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InsStat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef InsStat_LocationStat LocationStat;
  static const LocationStat LOCATION_VALID =
    InsStat_LocationStat_LOCATION_VALID;
  static const LocationStat LOCATION_INVALID =
    InsStat_LocationStat_LOCATION_INVALID;
  static inline bool LocationStat_IsValid(int value) {
    return InsStat_LocationStat_IsValid(value);
  }
  static const LocationStat LocationStat_MIN =
    InsStat_LocationStat_LocationStat_MIN;
  static const LocationStat LocationStat_MAX =
    InsStat_LocationStat_LocationStat_MAX;
  static const int LocationStat_ARRAYSIZE =
    InsStat_LocationStat_LocationStat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LocationStat_descriptor() {
    return InsStat_LocationStat_descriptor();
  }
  static inline const ::std::string& LocationStat_Name(LocationStat value) {
    return InsStat_LocationStat_Name(value);
  }
  static inline bool LocationStat_Parse(const ::std::string& name,
      LocationStat* value) {
    return InsStat_LocationStat_Parse(name, value);
  }

  typedef InsStat_DirectionFinderStat DirectionFinderStat;
  static const DirectionFinderStat GPS_ORIENTATION =
    InsStat_DirectionFinderStat_GPS_ORIENTATION;
  static const DirectionFinderStat GYRO_ORIENTATION =
    InsStat_DirectionFinderStat_GYRO_ORIENTATION;
  static inline bool DirectionFinderStat_IsValid(int value) {
    return InsStat_DirectionFinderStat_IsValid(value);
  }
  static const DirectionFinderStat DirectionFinderStat_MIN =
    InsStat_DirectionFinderStat_DirectionFinderStat_MIN;
  static const DirectionFinderStat DirectionFinderStat_MAX =
    InsStat_DirectionFinderStat_DirectionFinderStat_MAX;
  static const int DirectionFinderStat_ARRAYSIZE =
    InsStat_DirectionFinderStat_DirectionFinderStat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DirectionFinderStat_descriptor() {
    return InsStat_DirectionFinderStat_descriptor();
  }
  static inline const ::std::string& DirectionFinderStat_Name(DirectionFinderStat value) {
    return InsStat_DirectionFinderStat_Name(value);
  }
  static inline bool DirectionFinderStat_Parse(const ::std::string& name,
      DirectionFinderStat* value) {
    return InsStat_DirectionFinderStat_Parse(name, value);
  }

  typedef InsStat_GPSLocationStat GPSLocationStat;
  static const GPSLocationStat GPS_NO_LOCATION =
    InsStat_GPSLocationStat_GPS_NO_LOCATION;
  static const GPSLocationStat GPS_SINGLE_LOCATION =
    InsStat_GPSLocationStat_GPS_SINGLE_LOCATION;
  static const GPSLocationStat GPS_DIFF_LOCATION =
    InsStat_GPSLocationStat_GPS_DIFF_LOCATION;
  static const GPSLocationStat GPS_RTK_FIXED_LOCATION =
    InsStat_GPSLocationStat_GPS_RTK_FIXED_LOCATION;
  static const GPSLocationStat GPS_RTK_FLOAT_LOCATION =
    InsStat_GPSLocationStat_GPS_RTK_FLOAT_LOCATION;
  static inline bool GPSLocationStat_IsValid(int value) {
    return InsStat_GPSLocationStat_IsValid(value);
  }
  static const GPSLocationStat GPSLocationStat_MIN =
    InsStat_GPSLocationStat_GPSLocationStat_MIN;
  static const GPSLocationStat GPSLocationStat_MAX =
    InsStat_GPSLocationStat_GPSLocationStat_MAX;
  static const int GPSLocationStat_ARRAYSIZE =
    InsStat_GPSLocationStat_GPSLocationStat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GPSLocationStat_descriptor() {
    return InsStat_GPSLocationStat_descriptor();
  }
  static inline const ::std::string& GPSLocationStat_Name(GPSLocationStat value) {
    return InsStat_GPSLocationStat_Name(value);
  }
  static inline bool GPSLocationStat_Parse(const ::std::string& name,
      GPSLocationStat* value) {
    return InsStat_GPSLocationStat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .usv.localization.gnss.InsStat.LocationStat locationStat = 1;
  bool has_locationstat() const;
  void clear_locationstat();
  static const int kLocationStatFieldNumber = 1;
  ::usv::localization::gnss::InsStat_LocationStat locationstat() const;
  void set_locationstat(::usv::localization::gnss::InsStat_LocationStat value);

  // optional .usv.localization.gnss.InsStat.DirectionFinderStat directionFinderStat = 2;
  bool has_directionfinderstat() const;
  void clear_directionfinderstat();
  static const int kDirectionFinderStatFieldNumber = 2;
  ::usv::localization::gnss::InsStat_DirectionFinderStat directionfinderstat() const;
  void set_directionfinderstat(::usv::localization::gnss::InsStat_DirectionFinderStat value);

  // optional .usv.localization.gnss.InsStat.GPSLocationStat gpsLocationStat = 3;
  bool has_gpslocationstat() const;
  void clear_gpslocationstat();
  static const int kGpsLocationStatFieldNumber = 3;
  ::usv::localization::gnss::InsStat_GPSLocationStat gpslocationstat() const;
  void set_gpslocationstat(::usv::localization::gnss::InsStat_GPSLocationStat value);

  // optional int32 using_satellite_num = 4;
  bool has_using_satellite_num() const;
  void clear_using_satellite_num();
  static const int kUsingSatelliteNumFieldNumber = 4;
  ::google::protobuf::int32 using_satellite_num() const;
  void set_using_satellite_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:usv.localization.gnss.InsStat)
 private:
  void set_has_locationstat();
  void clear_has_locationstat();
  void set_has_directionfinderstat();
  void clear_has_directionfinderstat();
  void set_has_gpslocationstat();
  void clear_has_gpslocationstat();
  void set_has_using_satellite_num();
  void clear_has_using_satellite_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int locationstat_;
  int directionfinderstat_;
  int gpslocationstat_;
  ::google::protobuf::int32 using_satellite_num_;
  friend struct protobuf_gnss_5fun237_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InsTime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:usv.localization.gnss.InsTime) */ {
 public:
  InsTime();
  virtual ~InsTime();

  InsTime(const InsTime& from);

  inline InsTime& operator=(const InsTime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsTime(InsTime&& from) noexcept
    : InsTime() {
    *this = ::std::move(from);
  }

  inline InsTime& operator=(InsTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsTime& default_instance();

  static inline const InsTime* internal_default_instance() {
    return reinterpret_cast<const InsTime*>(
               &_InsTime_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(InsTime* other);
  friend void swap(InsTime& a, InsTime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsTime* New() const PROTOBUF_FINAL { return New(NULL); }

  InsTime* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InsTime& from);
  void MergeFrom(const InsTime& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InsTime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 year = 1;
  bool has_year() const;
  void clear_year();
  static const int kYearFieldNumber = 1;
  ::google::protobuf::int32 year() const;
  void set_year(::google::protobuf::int32 value);

  // optional int32 month = 2;
  bool has_month() const;
  void clear_month();
  static const int kMonthFieldNumber = 2;
  ::google::protobuf::int32 month() const;
  void set_month(::google::protobuf::int32 value);

  // optional int32 date = 3;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 3;
  ::google::protobuf::int32 date() const;
  void set_date(::google::protobuf::int32 value);

  // optional int32 hour = 4;
  bool has_hour() const;
  void clear_hour();
  static const int kHourFieldNumber = 4;
  ::google::protobuf::int32 hour() const;
  void set_hour(::google::protobuf::int32 value);

  // optional int32 minute = 5;
  bool has_minute() const;
  void clear_minute();
  static const int kMinuteFieldNumber = 5;
  ::google::protobuf::int32 minute() const;
  void set_minute(::google::protobuf::int32 value);

  // optional int32 second = 6;
  bool has_second() const;
  void clear_second();
  static const int kSecondFieldNumber = 6;
  ::google::protobuf::int32 second() const;
  void set_second(::google::protobuf::int32 value);

  // optional int32 second_decade = 7;
  bool has_second_decade() const;
  void clear_second_decade();
  static const int kSecondDecadeFieldNumber = 7;
  ::google::protobuf::int32 second_decade() const;
  void set_second_decade(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:usv.localization.gnss.InsTime)
 private:
  void set_has_year();
  void clear_has_year();
  void set_has_month();
  void clear_has_month();
  void set_has_date();
  void clear_has_date();
  void set_has_hour();
  void clear_has_hour();
  void set_has_minute();
  void clear_has_minute();
  void set_has_second();
  void clear_has_second();
  void set_has_second_decade();
  void clear_has_second_decade();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 year_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 date_;
  ::google::protobuf::int32 hour_;
  ::google::protobuf::int32 minute_;
  ::google::protobuf::int32 second_;
  ::google::protobuf::int32 second_decade_;
  friend struct protobuf_gnss_5fun237_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ins_un237 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:usv.localization.gnss.Ins_un237) */ {
 public:
  Ins_un237();
  virtual ~Ins_un237();

  Ins_un237(const Ins_un237& from);

  inline Ins_un237& operator=(const Ins_un237& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ins_un237(Ins_un237&& from) noexcept
    : Ins_un237() {
    *this = ::std::move(from);
  }

  inline Ins_un237& operator=(Ins_un237&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ins_un237& default_instance();

  static inline const Ins_un237* internal_default_instance() {
    return reinterpret_cast<const Ins_un237*>(
               &_Ins_un237_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Ins_un237* other);
  friend void swap(Ins_un237& a, Ins_un237& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ins_un237* New() const PROTOBUF_FINAL { return New(NULL); }

  Ins_un237* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ins_un237& from);
  void MergeFrom(const Ins_un237& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ins_un237* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .usv.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::usv::common::Header& header() const;
  ::usv::common::Header* mutable_header();
  ::usv::common::Header* release_header();
  void set_allocated_header(::usv::common::Header* header);

  // optional .usv.localization.gnss.InsStat insStat = 2;
  bool has_insstat() const;
  void clear_insstat();
  static const int kInsStatFieldNumber = 2;
  const ::usv::localization::gnss::InsStat& insstat() const;
  ::usv::localization::gnss::InsStat* mutable_insstat();
  ::usv::localization::gnss::InsStat* release_insstat();
  void set_allocated_insstat(::usv::localization::gnss::InsStat* insstat);

  // optional .usv.localization.gnss.InsTime insTime = 3;
  bool has_instime() const;
  void clear_instime();
  static const int kInsTimeFieldNumber = 3;
  const ::usv::localization::gnss::InsTime& instime() const;
  ::usv::localization::gnss::InsTime* mutable_instime();
  ::usv::localization::gnss::InsTime* release_instime();
  void set_allocated_instime(::usv::localization::gnss::InsTime* instime);

  // optional .usv.common.PointLLH postion = 4;
  bool has_postion() const;
  void clear_postion();
  static const int kPostionFieldNumber = 4;
  const ::usv::common::PointLLH& postion() const;
  ::usv::common::PointLLH* mutable_postion();
  ::usv::common::PointLLH* release_postion();
  void set_allocated_postion(::usv::common::PointLLH* postion);

  // optional double speed = 5;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  double speed() const;
  void set_speed(double value);

  // optional double heading = 6;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 6;
  double heading() const;
  void set_heading(double value);

  // optional double motionDirection = 7;
  bool has_motiondirection() const;
  void clear_motiondirection();
  static const int kMotionDirectionFieldNumber = 7;
  double motiondirection() const;
  void set_motiondirection(double value);

  // optional double rot = 8;
  bool has_rot() const;
  void clear_rot();
  static const int kRotFieldNumber = 8;
  double rot() const;
  void set_rot(double value);

  // optional double heave = 9;
  bool has_heave() const;
  void clear_heave();
  static const int kHeaveFieldNumber = 9;
  double heave() const;
  void set_heave(double value);

  // optional double pitch = 10;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 10;
  double pitch() const;
  void set_pitch(double value);

  // optional double roll = 11;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 11;
  double roll() const;
  void set_roll(double value);

  // @@protoc_insertion_point(class_scope:usv.localization.gnss.Ins_un237)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_insstat();
  void clear_has_insstat();
  void set_has_instime();
  void clear_has_instime();
  void set_has_postion();
  void clear_has_postion();
  void set_has_speed();
  void clear_has_speed();
  void set_has_heading();
  void clear_has_heading();
  void set_has_motiondirection();
  void clear_has_motiondirection();
  void set_has_rot();
  void clear_has_rot();
  void set_has_heave();
  void clear_has_heave();
  void set_has_pitch();
  void clear_has_pitch();
  void set_has_roll();
  void clear_has_roll();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::usv::common::Header* header_;
  ::usv::localization::gnss::InsStat* insstat_;
  ::usv::localization::gnss::InsTime* instime_;
  ::usv::common::PointLLH* postion_;
  double speed_;
  double heading_;
  double motiondirection_;
  double rot_;
  double heave_;
  double pitch_;
  double roll_;
  friend struct protobuf_gnss_5fun237_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InsStat

// optional .usv.localization.gnss.InsStat.LocationStat locationStat = 1;
inline bool InsStat::has_locationstat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsStat::set_has_locationstat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsStat::clear_has_locationstat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsStat::clear_locationstat() {
  locationstat_ = 0;
  clear_has_locationstat();
}
inline ::usv::localization::gnss::InsStat_LocationStat InsStat::locationstat() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsStat.locationStat)
  return static_cast< ::usv::localization::gnss::InsStat_LocationStat >(locationstat_);
}
inline void InsStat::set_locationstat(::usv::localization::gnss::InsStat_LocationStat value) {
  assert(::usv::localization::gnss::InsStat_LocationStat_IsValid(value));
  set_has_locationstat();
  locationstat_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsStat.locationStat)
}

// optional .usv.localization.gnss.InsStat.DirectionFinderStat directionFinderStat = 2;
inline bool InsStat::has_directionfinderstat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsStat::set_has_directionfinderstat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsStat::clear_has_directionfinderstat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsStat::clear_directionfinderstat() {
  directionfinderstat_ = 0;
  clear_has_directionfinderstat();
}
inline ::usv::localization::gnss::InsStat_DirectionFinderStat InsStat::directionfinderstat() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsStat.directionFinderStat)
  return static_cast< ::usv::localization::gnss::InsStat_DirectionFinderStat >(directionfinderstat_);
}
inline void InsStat::set_directionfinderstat(::usv::localization::gnss::InsStat_DirectionFinderStat value) {
  assert(::usv::localization::gnss::InsStat_DirectionFinderStat_IsValid(value));
  set_has_directionfinderstat();
  directionfinderstat_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsStat.directionFinderStat)
}

// optional .usv.localization.gnss.InsStat.GPSLocationStat gpsLocationStat = 3;
inline bool InsStat::has_gpslocationstat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsStat::set_has_gpslocationstat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsStat::clear_has_gpslocationstat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsStat::clear_gpslocationstat() {
  gpslocationstat_ = 0;
  clear_has_gpslocationstat();
}
inline ::usv::localization::gnss::InsStat_GPSLocationStat InsStat::gpslocationstat() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsStat.gpsLocationStat)
  return static_cast< ::usv::localization::gnss::InsStat_GPSLocationStat >(gpslocationstat_);
}
inline void InsStat::set_gpslocationstat(::usv::localization::gnss::InsStat_GPSLocationStat value) {
  assert(::usv::localization::gnss::InsStat_GPSLocationStat_IsValid(value));
  set_has_gpslocationstat();
  gpslocationstat_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsStat.gpsLocationStat)
}

// optional int32 using_satellite_num = 4;
inline bool InsStat::has_using_satellite_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InsStat::set_has_using_satellite_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InsStat::clear_has_using_satellite_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InsStat::clear_using_satellite_num() {
  using_satellite_num_ = 0;
  clear_has_using_satellite_num();
}
inline ::google::protobuf::int32 InsStat::using_satellite_num() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsStat.using_satellite_num)
  return using_satellite_num_;
}
inline void InsStat::set_using_satellite_num(::google::protobuf::int32 value) {
  set_has_using_satellite_num();
  using_satellite_num_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsStat.using_satellite_num)
}

// -------------------------------------------------------------------

// InsTime

// optional int32 year = 1;
inline bool InsTime::has_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsTime::set_has_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsTime::clear_has_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsTime::clear_year() {
  year_ = 0;
  clear_has_year();
}
inline ::google::protobuf::int32 InsTime::year() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsTime.year)
  return year_;
}
inline void InsTime::set_year(::google::protobuf::int32 value) {
  set_has_year();
  year_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsTime.year)
}

// optional int32 month = 2;
inline bool InsTime::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsTime::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsTime::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsTime::clear_month() {
  month_ = 0;
  clear_has_month();
}
inline ::google::protobuf::int32 InsTime::month() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsTime.month)
  return month_;
}
inline void InsTime::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsTime.month)
}

// optional int32 date = 3;
inline bool InsTime::has_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsTime::set_has_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsTime::clear_has_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsTime::clear_date() {
  date_ = 0;
  clear_has_date();
}
inline ::google::protobuf::int32 InsTime::date() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsTime.date)
  return date_;
}
inline void InsTime::set_date(::google::protobuf::int32 value) {
  set_has_date();
  date_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsTime.date)
}

// optional int32 hour = 4;
inline bool InsTime::has_hour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InsTime::set_has_hour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InsTime::clear_has_hour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InsTime::clear_hour() {
  hour_ = 0;
  clear_has_hour();
}
inline ::google::protobuf::int32 InsTime::hour() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsTime.hour)
  return hour_;
}
inline void InsTime::set_hour(::google::protobuf::int32 value) {
  set_has_hour();
  hour_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsTime.hour)
}

// optional int32 minute = 5;
inline bool InsTime::has_minute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InsTime::set_has_minute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InsTime::clear_has_minute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InsTime::clear_minute() {
  minute_ = 0;
  clear_has_minute();
}
inline ::google::protobuf::int32 InsTime::minute() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsTime.minute)
  return minute_;
}
inline void InsTime::set_minute(::google::protobuf::int32 value) {
  set_has_minute();
  minute_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsTime.minute)
}

// optional int32 second = 6;
inline bool InsTime::has_second() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InsTime::set_has_second() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InsTime::clear_has_second() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InsTime::clear_second() {
  second_ = 0;
  clear_has_second();
}
inline ::google::protobuf::int32 InsTime::second() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsTime.second)
  return second_;
}
inline void InsTime::set_second(::google::protobuf::int32 value) {
  set_has_second();
  second_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsTime.second)
}

// optional int32 second_decade = 7;
inline bool InsTime::has_second_decade() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InsTime::set_has_second_decade() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InsTime::clear_has_second_decade() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InsTime::clear_second_decade() {
  second_decade_ = 0;
  clear_has_second_decade();
}
inline ::google::protobuf::int32 InsTime::second_decade() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.InsTime.second_decade)
  return second_decade_;
}
inline void InsTime::set_second_decade(::google::protobuf::int32 value) {
  set_has_second_decade();
  second_decade_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.InsTime.second_decade)
}

// -------------------------------------------------------------------

// Ins_un237

// optional .usv.common.Header header = 1;
inline bool Ins_un237::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ins_un237::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ins_un237::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ins_un237::clear_header() {
  if (header_ != NULL) header_->::usv::common::Header::Clear();
  clear_has_header();
}
inline const ::usv::common::Header& Ins_un237::header() const {
  const ::usv::common::Header* p = header_;
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.header)
  return p != NULL ? *p : *reinterpret_cast<const ::usv::common::Header*>(
      &::usv::common::_Header_default_instance_);
}
inline ::usv::common::Header* Ins_un237::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::usv::common::Header;
  }
  // @@protoc_insertion_point(field_mutable:usv.localization.gnss.Ins_un237.header)
  return header_;
}
inline ::usv::common::Header* Ins_un237::release_header() {
  // @@protoc_insertion_point(field_release:usv.localization.gnss.Ins_un237.header)
  clear_has_header();
  ::usv::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Ins_un237::set_allocated_header(::usv::common::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:usv.localization.gnss.Ins_un237.header)
}

// optional .usv.localization.gnss.InsStat insStat = 2;
inline bool Ins_un237::has_insstat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ins_un237::set_has_insstat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ins_un237::clear_has_insstat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ins_un237::clear_insstat() {
  if (insstat_ != NULL) insstat_->::usv::localization::gnss::InsStat::Clear();
  clear_has_insstat();
}
inline const ::usv::localization::gnss::InsStat& Ins_un237::insstat() const {
  const ::usv::localization::gnss::InsStat* p = insstat_;
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.insStat)
  return p != NULL ? *p : *reinterpret_cast<const ::usv::localization::gnss::InsStat*>(
      &::usv::localization::gnss::_InsStat_default_instance_);
}
inline ::usv::localization::gnss::InsStat* Ins_un237::mutable_insstat() {
  set_has_insstat();
  if (insstat_ == NULL) {
    insstat_ = new ::usv::localization::gnss::InsStat;
  }
  // @@protoc_insertion_point(field_mutable:usv.localization.gnss.Ins_un237.insStat)
  return insstat_;
}
inline ::usv::localization::gnss::InsStat* Ins_un237::release_insstat() {
  // @@protoc_insertion_point(field_release:usv.localization.gnss.Ins_un237.insStat)
  clear_has_insstat();
  ::usv::localization::gnss::InsStat* temp = insstat_;
  insstat_ = NULL;
  return temp;
}
inline void Ins_un237::set_allocated_insstat(::usv::localization::gnss::InsStat* insstat) {
  delete insstat_;
  insstat_ = insstat;
  if (insstat) {
    set_has_insstat();
  } else {
    clear_has_insstat();
  }
  // @@protoc_insertion_point(field_set_allocated:usv.localization.gnss.Ins_un237.insStat)
}

// optional .usv.localization.gnss.InsTime insTime = 3;
inline bool Ins_un237::has_instime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ins_un237::set_has_instime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ins_un237::clear_has_instime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ins_un237::clear_instime() {
  if (instime_ != NULL) instime_->::usv::localization::gnss::InsTime::Clear();
  clear_has_instime();
}
inline const ::usv::localization::gnss::InsTime& Ins_un237::instime() const {
  const ::usv::localization::gnss::InsTime* p = instime_;
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.insTime)
  return p != NULL ? *p : *reinterpret_cast<const ::usv::localization::gnss::InsTime*>(
      &::usv::localization::gnss::_InsTime_default_instance_);
}
inline ::usv::localization::gnss::InsTime* Ins_un237::mutable_instime() {
  set_has_instime();
  if (instime_ == NULL) {
    instime_ = new ::usv::localization::gnss::InsTime;
  }
  // @@protoc_insertion_point(field_mutable:usv.localization.gnss.Ins_un237.insTime)
  return instime_;
}
inline ::usv::localization::gnss::InsTime* Ins_un237::release_instime() {
  // @@protoc_insertion_point(field_release:usv.localization.gnss.Ins_un237.insTime)
  clear_has_instime();
  ::usv::localization::gnss::InsTime* temp = instime_;
  instime_ = NULL;
  return temp;
}
inline void Ins_un237::set_allocated_instime(::usv::localization::gnss::InsTime* instime) {
  delete instime_;
  instime_ = instime;
  if (instime) {
    set_has_instime();
  } else {
    clear_has_instime();
  }
  // @@protoc_insertion_point(field_set_allocated:usv.localization.gnss.Ins_un237.insTime)
}

// optional .usv.common.PointLLH postion = 4;
inline bool Ins_un237::has_postion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ins_un237::set_has_postion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ins_un237::clear_has_postion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ins_un237::clear_postion() {
  if (postion_ != NULL) postion_->::usv::common::PointLLH::Clear();
  clear_has_postion();
}
inline const ::usv::common::PointLLH& Ins_un237::postion() const {
  const ::usv::common::PointLLH* p = postion_;
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.postion)
  return p != NULL ? *p : *reinterpret_cast<const ::usv::common::PointLLH*>(
      &::usv::common::_PointLLH_default_instance_);
}
inline ::usv::common::PointLLH* Ins_un237::mutable_postion() {
  set_has_postion();
  if (postion_ == NULL) {
    postion_ = new ::usv::common::PointLLH;
  }
  // @@protoc_insertion_point(field_mutable:usv.localization.gnss.Ins_un237.postion)
  return postion_;
}
inline ::usv::common::PointLLH* Ins_un237::release_postion() {
  // @@protoc_insertion_point(field_release:usv.localization.gnss.Ins_un237.postion)
  clear_has_postion();
  ::usv::common::PointLLH* temp = postion_;
  postion_ = NULL;
  return temp;
}
inline void Ins_un237::set_allocated_postion(::usv::common::PointLLH* postion) {
  delete postion_;
  postion_ = postion;
  if (postion) {
    set_has_postion();
  } else {
    clear_has_postion();
  }
  // @@protoc_insertion_point(field_set_allocated:usv.localization.gnss.Ins_un237.postion)
}

// optional double speed = 5;
inline bool Ins_un237::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ins_un237::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ins_un237::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ins_un237::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double Ins_un237::speed() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.speed)
  return speed_;
}
inline void Ins_un237::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.Ins_un237.speed)
}

// optional double heading = 6;
inline bool Ins_un237::has_heading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ins_un237::set_has_heading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ins_un237::clear_has_heading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ins_un237::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double Ins_un237::heading() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.heading)
  return heading_;
}
inline void Ins_un237::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.Ins_un237.heading)
}

// optional double motionDirection = 7;
inline bool Ins_un237::has_motiondirection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ins_un237::set_has_motiondirection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ins_un237::clear_has_motiondirection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ins_un237::clear_motiondirection() {
  motiondirection_ = 0;
  clear_has_motiondirection();
}
inline double Ins_un237::motiondirection() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.motionDirection)
  return motiondirection_;
}
inline void Ins_un237::set_motiondirection(double value) {
  set_has_motiondirection();
  motiondirection_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.Ins_un237.motionDirection)
}

// optional double rot = 8;
inline bool Ins_un237::has_rot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ins_un237::set_has_rot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ins_un237::clear_has_rot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ins_un237::clear_rot() {
  rot_ = 0;
  clear_has_rot();
}
inline double Ins_un237::rot() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.rot)
  return rot_;
}
inline void Ins_un237::set_rot(double value) {
  set_has_rot();
  rot_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.Ins_un237.rot)
}

// optional double heave = 9;
inline bool Ins_un237::has_heave() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ins_un237::set_has_heave() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ins_un237::clear_has_heave() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ins_un237::clear_heave() {
  heave_ = 0;
  clear_has_heave();
}
inline double Ins_un237::heave() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.heave)
  return heave_;
}
inline void Ins_un237::set_heave(double value) {
  set_has_heave();
  heave_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.Ins_un237.heave)
}

// optional double pitch = 10;
inline bool Ins_un237::has_pitch() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ins_un237::set_has_pitch() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ins_un237::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ins_un237::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline double Ins_un237::pitch() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.pitch)
  return pitch_;
}
inline void Ins_un237::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.Ins_un237.pitch)
}

// optional double roll = 11;
inline bool Ins_un237::has_roll() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ins_un237::set_has_roll() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Ins_un237::clear_has_roll() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Ins_un237::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline double Ins_un237::roll() const {
  // @@protoc_insertion_point(field_get:usv.localization.gnss.Ins_un237.roll)
  return roll_;
}
inline void Ins_un237::set_roll(double value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:usv.localization.gnss.Ins_un237.roll)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace gnss
}  // namespace localization
}  // namespace usv

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::usv::localization::gnss::InsStat_LocationStat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::usv::localization::gnss::InsStat_LocationStat>() {
  return ::usv::localization::gnss::InsStat_LocationStat_descriptor();
}
template <> struct is_proto_enum< ::usv::localization::gnss::InsStat_DirectionFinderStat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::usv::localization::gnss::InsStat_DirectionFinderStat>() {
  return ::usv::localization::gnss::InsStat_DirectionFinderStat_descriptor();
}
template <> struct is_proto_enum< ::usv::localization::gnss::InsStat_GPSLocationStat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::usv::localization::gnss::InsStat_GPSLocationStat>() {
  return ::usv::localization::gnss::InsStat_GPSLocationStat_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gnss_5fun237_2eproto__INCLUDED
